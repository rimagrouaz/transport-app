pipeline {
    agent none

    environment {
        DOCKER_USER = 'rimagrouaz'
        APP_NAME = 'transport-app'
        APP_VERSION = "v${env.BUILD_NUMBER}"
        KUBE_NAMESPACE = 'transport'
        IMAGE_FULL_NAME = "${DOCKER_USER}/${APP_NAME}:${APP_VERSION}"
    }

    options {
        timeout(time: 20, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    stages {

        stage('üîç Checkout') {
            agent any
            steps {
                echo 'üì• Checking out source code...'
                checkout scm
                stash includes: '**', name: 'source-code'
            }
        }

        stage('üêç Install Dependencies & Run Tests') {
            agent {
                docker {
                    image 'docker:24-dind'
                    args '--privileged -v /var/run/docker.sock:/var/run/docker.sock'
                }
            }
            steps {
                unstash 'source-code'
                echo 'üì¶ Installing Python dependencies...'
                dir('transport-optimization-devops/app') {
                    sh '''
                        python -m pip install --upgrade pip
                        pip install -r requirements.txt
                    '''
                }
                
                echo 'üß™ Running tests (if any)...'
                dir('transport-optimization-devops/app') {
                    sh 'python -m pytest tests/ || exit 0'
                }
            }
        }

        stage('üê≥ Build Docker Image & Push to DockerHub') {
            agent {
                docker {
                    image 'docker:24-dind'
                    args '--privileged -v /var/run/docker.sock:/var/run/docker.sock'
                }
            }
            steps {
                unstash 'source-code'
                echo 'üèóÔ∏è Building Docker image...'
                withCredentials([usernamePassword(
                    credentialsId: 'dockerhub-credentials',
                    usernameVariable: 'DOCKER_USERNAME',
                    passwordVariable: 'DOCKER_PASSWORD'
                )]) {
                    dir('transport-optimization-devops') {
                        sh '''
                            echo "üîê Connexion √† DockerHub..."
                            echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
                            
                            echo "üî® Build de l'image Docker..."
                            docker build \
                                -t ${IMAGE_FULL_NAME} \
                                -t ${DOCKER_USER}/${APP_NAME}:latest \
                                -f docker/Dockerfile .
                            
                            echo "üì§ Push vers DockerHub..."
                            docker push ${IMAGE_FULL_NAME}
                            docker push ${DOCKER_USER}/${APP_NAME}:latest
                            
                            echo "‚úÖ Image publi√©e : ${IMAGE_FULL_NAME}"
                        '''
                    }
                }
            }
        }

        stage('‚ò∏Ô∏è Kubernetes Connectivity Check') {
            agent {
                docker {
                    image 'bitnami/kubectl:1.28'
                    args '--entrypoint= -u root'
                }
            }
            steps {
                unstash 'source-code'
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECFG')]) {
                    sh '''
                        echo "üîç Checking Kubernetes access..."
                        mkdir -p ~/.kube
                        cp ${KUBECFG} ~/.kube/config
                        sed -i 's/127.0.0.1/host.docker.internal/g' ~/.kube/config
                        
                        kubectl --insecure-skip-tls-verify=true version --client
                        kubectl --insecure-skip-tls-verify=true get nodes || echo "‚ö†Ô∏è Cannot access nodes (might be normal)"
                    '''
                }
            }
        }

        stage('üìÅ Create Namespace') {
            agent {
                docker {
                    image 'bitnami/kubectl:1.28'
                    args '--entrypoint= -u root'
                }
            }
            steps {
                unstash 'source-code'
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECFG')]) {
                    sh '''
                        echo "üìÅ Ensuring Kubernetes namespace exists..."
                        mkdir -p ~/.kube
                        cp ${KUBECFG} ~/.kube/config
                        sed -i 's/127.0.0.1/host.docker.internal/g' ~/.kube/config
                        
                        kubectl --insecure-skip-tls-verify=true create namespace ${KUBE_NAMESPACE} --dry-run=client -o yaml | \
                        kubectl --insecure-skip-tls-verify=true apply -f -
                    '''
                }
            }
        }

        stage('üöÄ Deploy to Kubernetes') {
            agent {
                docker {
                    image 'bitnami/kubectl:1.28'
                    args '--entrypoint= -u root'
                }
            }
            steps {
                unstash 'source-code'
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECFG')]) {
                    sh '''
                        echo "üöÄ Deploying application to Kubernetes..."
                        mkdir -p ~/.kube
                        cp ${KUBECFG} ~/.kube/config
                        sed -i 's/127.0.0.1/host.docker.internal/g' ~/.kube/config
                        
                        # Fonction kubectl avec insecure
                        k() {
                            kubectl --insecure-skip-tls-verify=true "$@"
                        }
                        
                        echo "üóëÔ∏è Suppression de l'ancien d√©ploiement (si existant)..."
                        k delete deployment ${APP_NAME} -n ${KUBE_NAMESPACE} --ignore-not-found=true
                        
                        echo "üìÑ Application des manifests Kubernetes..."
                        k apply -f transport-optimization-devops/kubernetes/deployment.yaml -n ${KUBE_NAMESPACE}
                        k apply -f transport-optimization-devops/kubernetes/service.yaml -n ${KUBE_NAMESPACE}
                        
                        echo "üîÑ Mise √† jour de l'image vers ${IMAGE_FULL_NAME}..."
                        k set image deployment/${APP_NAME} ${APP_NAME}=${IMAGE_FULL_NAME} -n ${KUBE_NAMESPACE}
                    '''
                }
            }
        }

        stage('‚úÖ Verify Deployment') {
            agent {
                docker {
                    image 'bitnami/kubectl:1.28'
                    args '--entrypoint= -u root'
                }
            }
            steps {
                unstash 'source-code'
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECFG')]) {
                    sh '''
                        echo "‚úÖ Verifying deployment status..."
                        mkdir -p ~/.kube
                        cp ${KUBECFG} ~/.kube/config
                        sed -i 's/127.0.0.1/host.docker.internal/g' ~/.kube/config
                        
                        k() {
                            kubectl --insecure-skip-tls-verify=true "$@"
                        }
                        
                        echo "‚è≥ Waiting 15 seconds before checking status..."
                        sleep 15
                        
                        echo "üìä Rollout status:"
                        k rollout status deployment/${APP_NAME} -n ${KUBE_NAMESPACE} --timeout=3m
                        
                        echo ""
                        echo "üì¶ Pods status:"
                        k get pods -n ${KUBE_NAMESPACE} -o wide
                        
                        echo ""
                        echo "üåê Services:"
                        k get svc -n ${KUBE_NAMESPACE}
                    '''
                }
            }
        }

        stage('üåê Application URL') {
            agent {
                docker {
                    image 'bitnami/kubectl:1.28'
                    args '--entrypoint= -u root'
                }
            }
            steps {
                unstash 'source-code'
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECFG')]) {
                    sh '''
                        echo "üåê Getting application access information..."
                        mkdir -p ~/.kube
                        cp ${KUBECFG} ~/.kube/config
                        sed -i 's/127.0.0.1/host.docker.internal/g' ~/.kube/config
                        
                        k() {
                            kubectl --insecure-skip-tls-verify=true "$@"
                        }
                        
                        echo ""
                        echo "========================================"
                        echo "APPLICATION DEPLOYED SUCCESSFULLY!"
                        echo "========================================"
                        echo ""
                        echo "üê≥ Docker Image: ${IMAGE_FULL_NAME}"
                        echo "‚ò∏Ô∏è  Namespace: ${KUBE_NAMESPACE}"
                        echo ""
                        echo "Access your application:"
                        echo "1. Port Forward: kubectl port-forward -n ${KUBE_NAMESPACE} svc/${APP_NAME}-service 5000:80"
                        echo "2. Minikube: minikube service ${APP_NAME}-service -n ${KUBE_NAMESPACE}"
                        echo ""
                        
                        k get svc -n ${KUBE_NAMESPACE} ${APP_NAME}-service || k get svc -n ${KUBE_NAMESPACE}
                    '''
                }
            }
        }
    }

    post {
        success {
            echo '‚úÖ ‚úÖ ‚úÖ PIPELINE COMPLETED SUCCESSFULLY! ‚úÖ ‚úÖ ‚úÖ'
            echo 'üéâ Application deployed to Kubernetes cluster!'
            echo "üê≥ Docker Image: ${IMAGE_FULL_NAME}"
            echo "‚ò∏Ô∏è  Namespace: ${KUBE_NAMESPACE}"
            echo 'üì± Check the Application URL stage for access instructions'
        }
        failure {
            echo '‚ùå ‚ùå ‚ùå PIPELINE FAILED! ‚ùå ‚ùå ‚ùå'
            echo 'üìã Check the console output above for error details'
            echo 'üí° Common fixes:'
            echo '   - Ensure Jenkins has Docker socket access'
            echo '   - Verify DockerHub credentials are configured'
            echo '   - Check kubeconfig file is uploaded to Jenkins'
            echo '   - Ensure namespace and resources exist'
        }
        always {
            node('') {
                cleanWs(deleteDirs: true)
            }
            script {
                def date = new Date().format('yyyy-MM-dd HH:mm:ss')
                echo "üßπ Pipeline execution finished at ${date}"
            }
        }
    }
}
