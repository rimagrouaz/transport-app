pipeline {
    agent any

    environment {
        APP_NAME = 'transport-app'
        APP_VERSION = "v${env.BUILD_NUMBER}"
        KUBE_NAMESPACE = 'transport'
    }

    stages {
        stage('ğŸ” Checkout') {
            steps {
                echo 'ğŸ“¥ Checking out source code...'
                checkout scm
            }
        }

        // On regroupe Installation et Tests dans le mÃªme agent pour garder les paquets
        stage('ğŸ Python: Install & Test') {
            agent {
                docker {
                    image 'python:3.9-slim'
                    args '-u root'
                }
            }
            steps {
                echo 'ğŸ“¦ Installing Python dependencies & Running Tests...'
                dir('transport-optimization-devops/app') {
                    sh '''
                        python -m pip install --upgrade pip
                        pip install -r requirements.txt pytest
                        python -m pytest tests/ || echo "No tests found or tests failed"
                    '''
                }
            }
        }

        stage('ğŸ³ Build Docker Image (Local)') {
            steps {
                echo 'ğŸ—ï¸ Building Docker image locally...'
                dir('transport-optimization-devops') {
                    sh "docker build -t ${APP_NAME}:${APP_VERSION} -f docker/Dockerfile ."
                }
            }
        }

        // On utilise un agent Docker qui contient kubectl pour toutes les Ã©tapes K8s
        stage('â˜¸ï¸ Kubernetes: Deploy') {
            agent {
                docker {
                    image 'bitnami/kubectl:latest'
                    args '-u root'
                }
            }
            steps {
                echo 'ğŸš€ Deploying to Kubernetes...'
                dir('transport-optimization-devops') {
                    sh '''
                        echo "ğŸ” Checking Connectivity..."
                        kubectl version --client
                        
                        echo "ğŸ“ Ensuring Namespace exists..."
                        kubectl create namespace ${KUBE_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        
                        echo "ğŸš€ Deploying Resources..."
                        kubectl apply -f kubernetes/deployment.yaml -n ${KUBE_NAMESPACE}
                        kubectl apply -f kubernetes/service.yaml -n ${KUBE_NAMESPACE}
                        
                        echo "ğŸ”„ Updating Image..."
                        kubectl set image deployment/${APP_NAME} ${APP_NAME}=${APP_NAME}:${APP_VERSION} -n ${KUBE_NAMESPACE}
                        
                        echo "âœ… Verifying Deployment..."
                        sleep 10
                        kubectl rollout status deployment/${APP_NAME} -n ${KUBE_NAMESPACE} --timeout=3m
                    '''
                }
            }
        }

        stage('ğŸŒ Application URL') {
            steps {
                echo 'ğŸŒ Access Info:'
                sh "echo 'App URL: kubectl port-forward -n ${KUBE_NAMESPACE} svc/${APP_NAME}-service 5000:80'"
            }
        }
    }

    post {
        success {
            echo 'âœ… âœ… âœ… PIPELINE COMPLETED SUCCESSFULLY! âœ… âœ… âœ…'
        }
        failure {
            echo 'âŒ âŒ âŒ PIPELINE FAILED! âŒ âŒ âŒ'
        }
        always {
            sh 'docker image prune -f || true'
            echo "ğŸ§¹ Pipeline finished at ${new Date().format('yyyy-MM-dd HH:mm:ss')}"
        }
    }
}
