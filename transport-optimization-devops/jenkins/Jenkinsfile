pipeline {
    agent any

    environment {
        APP_NAME = 'transport-app'
        APP_VERSION = "v${env.BUILD_NUMBER}" // Version dynamique pour Ã©viter les conflits
        KUBE_NAMESPACE = 'transport'
    }

    stages {
        stage('ğŸ” Checkout') {
            steps {
                echo 'ğŸ“¥ Checking out source code...'
                checkout scm
            }
        }

        stage('ğŸ Install Dependencies') {
            // Ajout de l'agent Docker pour garantir la prÃ©sence de Python et Pip
            agent {
                docker {
                    image 'python:3.9-slim'
                    args '-u root'
                }
            }
            steps {
                echo 'ğŸ“¦ Installing Python dependencies...'
                dir('transport-optimization-devops/app') {
                    sh '''
                        python -m pip install --upgrade pip
                        pip install -r requirements.txt
                    '''
                }
            }
        }

        stage('ğŸ§ª Run Tests') {
            // On utilise le mÃªme agent pour les tests
            agent {
                docker {
                    image 'python:3.9-slim'
                    args '-u root'
                }
            }
            steps {
                echo 'ğŸ§ª Running tests (if any)...'
                dir('transport-optimization-devops/app') {
                    sh 'python -m pytest tests/ || echo "No tests found or tests failed"'
                }
            }
        }

        stage('ğŸ³ Build Docker Image (Local)') {
            steps {
                echo 'ğŸ—ï¸ Building Docker image locally...'
                dir('transport-optimization-devops') {
                    // Ici on utilise l'hÃ´te car Docker est dÃ©jÃ  sur Jenkins
                    sh "docker build -t ${APP_NAME}:${APP_VERSION} -f docker/Dockerfile ."
                }
            }
        }

        stage('â˜¸ï¸ Kubernetes Connectivity Check') {
            steps {
                echo 'ğŸ” Checking Kubernetes access...'
                sh '''
                    kubectl version --client
                    kubectl get nodes || echo "Cluster unreachable"
                '''
            }
        }

        stage('ğŸ“ Create Namespace') {
            steps {
                echo 'ğŸ“ Ensuring Kubernetes namespace exists...'
                sh "kubectl create namespace ${KUBE_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -"
            }
        }

        stage('ğŸš€ Deploy to Kubernetes') {
            steps {
                echo 'ğŸš€ Deploying application to Kubernetes...'
                sh '''
                    kubectl delete deployment ${APP_NAME} -n ${KUBE_NAMESPACE} --ignore-not-found=true
                    kubectl apply -f kubernetes/deployment.yaml -n ${KUBE_NAMESPACE}
                    kubectl apply -f kubernetes/service.yaml -n ${KUBE_NAMESPACE}
                '''
            }
        }

        stage('âœ… Verify Deployment') {
            steps {
                echo 'âœ… Verifying deployment status...'
                sh '''
                    sleep 15
                    kubectl rollout status deployment/${APP_NAME} -n ${KUBE_NAMESPACE} --timeout=3m
                    kubectl get pods -n ${KUBE_NAMESPACE} -o wide
                    kubectl get svc -n ${KUBE_NAMESPACE}
                '''
            }
        }

        stage('ğŸŒ Application URL') {
            steps {
                echo 'ğŸŒ Getting application access information...'
                sh '''
                    echo ""
                    echo "========================================"
                    echo "APPLICATION DEPLOYED SUCCESSFULLY!"
                    echo "========================================"
                    echo ""
                    echo "Access your application:"
                    echo "1. Port Forward: kubectl port-forward -n ${KUBE_NAMESPACE} svc/${APP_NAME}-service 5000:80"
                    echo ""
                    kubectl get svc -n ${KUBE_NAMESPACE}
                '''
            }
        }
    }

    post {
        success {
            echo 'âœ… âœ… âœ… PIPELINE COMPLETED SUCCESSFULLY! âœ… âœ… âœ…'
        }
        failure {
            echo 'âŒ âŒ âŒ PIPELINE FAILED! âŒ âŒ âŒ'
        }
        always {
            // Nettoyage pour ne pas saturer l'espace disque
            sh 'docker image prune -f || true'
            echo "ğŸ§¹ Pipeline finished at ${new Date().format('yyyy-MM-dd HH:mm:ss')}"
        }
    }
}
