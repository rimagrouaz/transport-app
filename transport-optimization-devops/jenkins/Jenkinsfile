pipeline {
    agent any

    environment {
        APP_NAME = 'transport-app'
        APP_VERSION = 'v2'
        KUBE_NAMESPACE = 'transport1' // ChangÃ© en transport1 pour correspondre Ã  vos tests prÃ©cÃ©dents
    }

    stages {

        stage('ğŸ” Checkout') {
            steps {
                echo 'ğŸ“¥ Checking out source code...'
                checkout scm
            }
        }

        stage('ğŸ Install Dependencies') {
            steps {
                echo 'ğŸ“¦ Installing Python dependencies...'
                dir('transport-optimization-devops/app') {
                    // Utilisation de sh et python3/pip3 (standard Linux)
                    sh '''
                        pip3 install --break-system-packages -r requirements.txt
                    '''
                }
            }
        }

        stage('ğŸ§ª Run Tests') {
            steps {
                echo 'ğŸ§ª Running tests (if any)...'
                dir('transport-optimization-devops/app') {
                    // || true permet de ne pas faire Ã©chouer le pipeline si pytest n'est pas installÃ©
                    sh 'python3 -m pytest tests/ || true'
                }
            }
        }

        stage('ğŸ³ Build Docker Image (Local)') {
            steps {
                echo 'ğŸ—ï¸ Building Docker image locally...'
                dir('transport-optimization-devops') {
                    // Syntaxe de variable Linux : ${VAR}
                    sh "docker build -t ${APP_NAME}:${APP_VERSION} -f docker/Dockerfile ."
                }
            }
        }

        stage('â˜¸ï¸ Kubernetes Connectivity Check') {
            steps {
                echo 'ğŸ” Checking Kubernetes access...'
                sh '''
                    kubectl version --client
                    kubectl cluster-info || echo "Cluster non accessible"
                '''
            }
        }

        stage('ğŸ“ Create Namespace') {
            steps {
                echo "ğŸ“ Ensuring Kubernetes namespace ${KUBE_NAMESPACE} exists..."
                sh "kubectl create namespace ${KUBE_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -"
            }
        }

        stage('ğŸš€ Deploy to Kubernetes') {
            steps {
                echo 'ğŸš€ Deploying application to Kubernetes...'
                // Les chemins doivent correspondre Ã  la structure de votre repo GitHub
                sh '''
                    kubectl apply -f kubernetes/deployment.yaml -n ${KUBE_NAMESPACE}
                    kubectl apply -f kubernetes/service.yaml -n ${KUBE_NAMESPACE}
                '''
            }
        }

        stage('âœ… Verify Deployment') {
            steps {
                echo 'âœ… Verifying deployment status...'
                sh '''
                    sleep 15
                    kubectl rollout status deployment/${APP_NAME} -n ${KUBE_NAMESPACE} --timeout=3m
                    kubectl get pods -n ${KUBE_NAMESPACE}
                '''
            }
        }

        stage('ğŸŒ Application URL') {
            steps {
                echo 'ğŸŒ Getting application access information...'
                sh '''
                    echo "========================================"
                    echo "APPLICATION DEPLOYED SUCCESSFULLY!"
                    echo "========================================"
                    echo "Access instructions:"
                    echo "Minikube: minikube service ${APP_NAME}-service -n ${KUBE_NAMESPACE}"
                '''
            }
        }
    }

    post {
        success {
            echo 'âœ… âœ… âœ… PIPELINE COMPLETED SUCCESSFULLY! âœ… âœ… âœ…'
        }
        failure {
            echo 'âŒ âŒ âŒ PIPELINE FAILED! âŒ âŒ âŒ'
        }
    }
}
