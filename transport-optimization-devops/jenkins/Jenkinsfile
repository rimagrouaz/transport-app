pipeline {
    agent any

    environment {
        APP_NAME = 'transport-app'
        // Version basÃ©e sur le numÃ©ro du build Jenkins
        APP_VERSION = "v${env.BUILD_NUMBER}"
        KUBE_NAMESPACE = 'transport'
    }

    stages {
        stage('ğŸ” Checkout') {
            steps {
                echo 'ğŸ“¥ RÃ©cupÃ©ration du code source...'
                checkout scm
            }
        }

        stage('ğŸ Python: Install & Test') {
            agent {
                docker {
                    image 'python:3.9-slim'
                    args '-u root'
                }
            }
            steps {
                echo 'ğŸ“¦ Installation des dÃ©pendances et Tests...'
                dir('transport-optimization-devops/app') {
                    sh '''
                        python -m pip install --upgrade pip
                        pip install -r requirements.txt pytest
                        # On exÃ©cute les tests, le pipeline continue mÃªme si aucun test n'est trouvÃ©
                        python -m pytest tests/ || echo "âš ï¸ Aucun test trouvÃ© ou Ã©chec des tests."
                    '''
                }
            }
        }

        stage('ğŸ³ Build Docker Image') {
            steps {
                echo 'ğŸ—ï¸ Construction de l image Docker locale...'
                dir('transport-optimization-devops') {
                    sh "docker build -t ${APP_NAME}:${APP_VERSION} -f docker/Dockerfile ."
                }
            }
        }

        stage('â˜¸ï¸ Kubernetes: Deploy') {
            agent {
                docker {
                    image 'bitnami/kubectl:latest'
                    // On force l'entrypoint vide pour que Jenkins puisse piloter le conteneur
                    args '-u root --entrypoint='
                }
            }
            steps {
                echo 'ğŸš€ DÃ©ploiement vers le cluster Kubernetes...'
                // Utilisation du Secret File crÃ©Ã© dans Jenkins
                withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECFG')]) {
                    dir('transport-optimization-devops') {
                        sh '''
                            # On dÃ©finit la variable d'environnement pour kubectl
                            export KUBECONFIG=${KUBECFG}
                            
                            echo "ğŸ” VÃ©rification de la connexion au cluster..."
                            kubectl cluster-info
                            
                            echo "ğŸ“ CrÃ©ation du namespace ${KUBE_NAMESPACE} si nÃ©cessaire..."
                            kubectl create namespace ${KUBE_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                            
                            echo "ğŸš€ Application des manifestes YAML..."
                            kubectl apply -f kubernetes/deployment.yaml -n ${KUBE_NAMESPACE}
                            kubectl apply -f kubernetes/service.yaml -n ${KUBE_NAMESPACE}
                            
                            echo "ğŸ”„ Mise Ã  jour de l image vers ${APP_VERSION}..."
                            kubectl set image deployment/${APP_NAME} ${APP_NAME}=${APP_NAME}:${APP_VERSION} -n ${KUBE_NAMESPACE}
                            
                            echo "âœ… VÃ©rification du statut du dÃ©ploiement..."
                            kubectl rollout status deployment/${APP_NAME} -n ${KUBE_NAMESPACE} --timeout=2m
                        '''
                    }
                }
            }
        }
    }

    post {
        success {
            echo 'âœ… âœ… âœ… PIPELINE TERMINÃ‰ AVEC SUCCÃˆS ! âœ… âœ… âœ…'
        }
        failure {
            echo 'âŒ âŒ âŒ LE PIPELINE A Ã‰CHOUÃ‰ ! âŒ âŒ âŒ'
        }
        always {
            echo 'ğŸ§¹ Nettoyage des images Docker intermÃ©diaires...'
            sh 'docker image prune -f || true'
        }
    }
}
